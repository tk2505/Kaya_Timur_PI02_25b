def insertion_sort(a):
    i = 1  # начинаем со второго элемента
    while i < len(a):  # пока есть элементы для вставки
        key = a[i]  # запоминаем текущий элемент
        j = i - 1  # сравниваем с элементами слева
        while j >= 0 and a[j] > key:  # сдвигаем большие элементы вправо
            a[j + 1] = a[j]  # выполняем сдвиг
            j -= 1  # двигаемся дальше влево
        a[j + 1] = key  # вставляем элемент на позицию
        i += 1  # переходим к следующему
    return a  # возвращаем отсортированную корзину (для удобства)

def bucket_sort(arr):  # блочная (корзинная) сортировка для чисел
    n = len(arr)  # размер входного массива
    if n < 2:  # быстрый выход для коротких списков
        return arr[:]  # возвращаем копию массива

    mn = min(arr)  # минимальное значение
    mx = max(arr)  # максимальное значение
    if mn == mx:  # все элементы равны — уже отсортировано
        return arr[:]  # возвращаем копию

    k = n  # число корзин (выбираем равно n для равномерных распределений)
    buckets = [[] for _ in range(k)]  # создаём список пустых корзин

    rng = mx - mn  # размах значений (для нормирования)
    for x in arr:  # распределяем все элементы по корзинам
        idx = int((x - mn) / rng * (k - 1))  # индекс корзины в диапазоне [0, k-1]
        buckets[idx].append(x)  # добавляем элемент в соответствующую корзину

    for b in buckets:  # сортируем элементы внутри каждой корзины
        insertion_sort(b)  # используем сортировку вставками (простая и эффективная для малых корзин)

    res = []  # результирующий список
    for b in buckets:  # конкатенируем отсортированные корзины слева направо
        res.extend(b)  # добавляем содержимое корзины к результату
    return res  # возвращаем отсортированный массив

# Демонстрация работы:
arr = [64, 34.5, 25, 12, 22.1, 11, 90, -5, 0, 3.14, 2.71, 1.41]  # тестовый набор чисел (int/float)
print("Исходный:", arr)  # печатаем исходный массив
sorted_arr = bucket_sort(arr)  # вызываем корзинную сортировку
print("Отсортированный:", sorted_arr)  # печатаем отсортированный результат
#Вывод: исходный [64, 34.5, 25, 12, 22.1, 11, 90, -5, 0, 3.14, 2.71, 1.41]
#отсортированный [-5, 0, 1.41, 2.71, 3.14, 11, 12, 22.1, 25, 34.5, 64, 90]


def flip(a, k):  # переворот префикса a[0..k] (включительно)
    a[:k + 1] = reversed(a[:k + 1])  # переворачиваем срез встроенной функцией reversed

def max_index(a, size):  # индекс максимума в префиксе a[0..size-1]
    mx_i = 0  # начально считаем максимумом a[0]
    i = 1  # начнём проверку со второго элемента
    while i < size:  # пока не пройдём весь префикс
        if a[i] > a[mx_i]:  # если найден элемент больше текущего максимума
            mx_i = i  # обновляем индекс максимума
        i += 1  # переходим к следующему элементу
    return mx_i  # возвращаем индекс максимума

def pancake_sort(a):  # блинная сортировка (in-place)
    n = len(a)  # длина массива
    size = n  # текущая длина рассматриваемого префикса
    while size > 1:  # пока префикс содержит больше одного элемента
        mi = max_index(a, size)  # находим индекс максимума в a[0..size-1]
        if mi != size - 1:  # если максимум не стоит в конце префикса
            if mi != 0:  # если максимум не в начале
                flip(a, mi)  # поднимаем максимум в начало префикса
            flip(a, size - 1)  # переносим максимум из начала в конец префикса
        size -= 1  # уменьшаем размер префикса и повторяем
    return a  # возвращаем отсортированный список (сортировка выполняется на месте)

# Демонстрация работы на встроенном массиве
arr = [9, 1, 8, 3, 7, 2, 6, 5, 4]  # тестовые данные
print("Исходный:", arr)  # печатаем исходный массив
pancake_sort(arr)  # вызываем блинную сортировку
print("Отсортированный:", arr)  # печатаем отсортированный результат
#Вывод: исходный [9, 1, 8, 3, 7, 2, 6, 5, 4]
# отсортированный: [1, 2, 3, 4, 5, 6, 7, 8, 9]


# bead sort / gravity sort
def bead_sort(arr):  # объявляем функцию сортировки
    if not arr:  # пустой список
        return []  # возвращаем пустой результат
    if any(x < 0 or int(x) != x for x in arr):  # проверяем, что все элементы неотрицательные целые
        raise ValueError("Bead sort требует неотрицательные целые числа")  # сообщаем об ограничении

    n = len(arr)  # количество строк (элементов)
    m = max(arr)  # максимальное значение (число «столбов»/высота решётки)

    if m == 0:  # если все нули
        return arr[:]  # уже отсортировано

    # создаём решётку n x m, заполненную нулями (0 = пусто, 1 = бусина)
    grid = [[0] * m for _ in range(n)]  # матрица бусин

    # расставляем бусины по строкам слева направо (row i содержит arr[i] единиц)
    for i, val in enumerate(arr):  # идём по исходным значениям
        for j in range(val):  # ставим val бусин в столбцы 0..val-1
            grid[i][j] = 1  # размещаем бусину

    # «роняем» бусины по каждому столбцу независимо
    for j in range(m):  # для каждого столбца считаем число бусин
        count = 0  # счётчик бусин в столбце
        for i in range(n):  # подсчитываем 1-цы сверху вниз
            count += grid[i][j]  # добавляем 1, если есть бусина
            grid[i][j] = 0  # обнуляем ячейку (все бусины «снимаем»)
        # кладём count бусин внизу столбца
        for i in range(n - 1, n - 1 - count, -1):  # снизу вверх count раз
            grid[i][j] = 1  # возвращаем бусины «упавшими» вниз

    # считываем отсортированный массив: число единиц в каждой строке слева направо
    res = [0] * n  # результирующий список
    for i in range(n):  # для каждой строки
        s = 0  # суммарное количество бусин
        for j in range(m):  # считаем единицы по столбцам
            s += grid[i][j]  # накапливаем 1-цы
        res[i] = s  # записываем число как длину «столбика» в строке
    return res  # возвращаем отсортированный список

# Демонстрация: неотсортированный список неотрицательных целых
arr = [5, 3, 1, 7, 4, 2, 6, 0]  # тестовые данные
print("Исходный:", arr)  # печать до сортировки
sorted_arr = bead_sort(arr)  # вызов гравитационной сортировки
print("Отсортированный:", sorted_arr)  # печать после сортировки
#Вывод: исходный: [5, 3, 1, 7, 4, 2, 6, 0]
#отсортированный: [0, 1, 2, 3, 4, 5, 6, 7]


import math  # модуль для вычисления квадратного корня

def jump_search(arr, target):  # поиск скачками: вернуть индекс или -1
    n = len(arr)  # длина массива
    if n == 0:  # быстрый выход для пустого массива
        return -1  # не найдено
    step = int(math.sqrt(n))  # оптимальный размер прыжка ? sqrt(n)
    prev = 0  # левая граница текущего блока
    # Прыгаем блоками, пока правый край блока < target и не вышли за массив
    while prev < n and arr[min(prev + step, n) - 1] < target:  # сравнение с концом блока
        prev += step  # прыжок к следующему блоку
        if prev >= n:  # вышли за пределы массива
            return -1  # не найдено
    # Линейный поиск внутри кандидата-блока [prev, min(prev+step, n))
    end = min(prev + step, n)  # правый край блока (исключительно)
    i = prev  # начинаем линейный просмотр
    while i < end and arr[i] < target:  # продвигаемся, пока значения меньше цели
        i += 1  # двигаемся на один элемент
    if i < end and i < n and arr[i] == target:  # проверяем успех поиска
        return i  # возвращаем индекс
    return -1  # элемент не найден

# Отсортированный тестовый массив
arr = [-10, -3, 0, 1, 3, 5, 7, 9, 11, 18, 23, 34, 42, 42, 58, 73, 99]  # демонстрационные данные
# Цели поиска
target_found = 42  # присутствует в массиве
target_missing = 100  # отсутствует

# Демонстрация работы
print("Массив:", arr)  # печать исходного массива
idx1 = jump_search(arr, target_found)  # ищем существующее значение
print(f"Ищем {target_found}: индекс =", idx1)  # результат «найдено»
idx2 = jump_search(arr, target_missing)  # ищем отсутствующее значение
print(f"Ищем {target_missing}: индекс =", idx2)  # результат «не найдено» (-1)
#Вывод: массив: [-10, -3, 0, 1, 3, 5, 7, 9, 11, 18, 23, 34, 42, 42, 58, 73, 99]
#ищем 42: индекс = 12
#ищем 100: индекс = -1



def binary_search(arr, left, right, target):  # бинарный поиск в диапазоне [left, right]
    while left <= right:  # пока диапазон не пуст
        mid = (left + right) // 2  # средний индекс
        if arr[mid] == target:  # если элемент найден
            return mid  # возвращаем индекс
        elif arr[mid] < target:  # если средний меньше цели
            left = mid + 1  # сдвигаем левую границу
        else:  # средний больше цели
            right = mid - 1  # сдвигаем правую границу
    return -1  # не найдено

def exponential_search(arr, target):  # экспоненциальный поиск
    n = len(arr)  # длина массива
    if n == 0:  # если массив пуст
        return -1  # элемент не найден
    if arr[0] == target:  # если первый элемент — искомый
        return 0  # возвращаем индекс 0
    # Фаза 1: находим диапазон, удваивая индекс
    i = 1  # начальный индекс для экспоненциального роста
    while i < n and arr[i] <= target:  # пока не вышли за массив и элемент <= цели
        i = i * 2  # удваиваем индекс (1, 2, 4, 8, 16, ...)
    # Фаза 2: бинарный поиск в диапазоне [i//2, min(i, n-1)]
    left = i // 2  # левая граница — половина последнего индекса
    right = min(i, n - 1)  # правая граница — минимум из i и последнего индекса массива
    return binary_search(arr, left, right, target)  # выполняем бинарный поиск

# Отсортированный тестовый массив
arr = [1, 3, 5, 7, 9, 11, 13, 15, 18, 23, 34, 42, 58, 73, 99, 127, 159, 356, 480, 567]  # данные
# Цели поиска
target_found = 42  # присутствует в массиве
target_missing = 100  # отсутствует

# Демонстрация работы
print("Массив:", arr)  # печать исходного массива
idx1 = exponential_search(arr, target_found)  # ищем существующее значение
print(f"Ищем {target_found}: индекс =", idx1)  # результат «найдено»
idx2 = exponential_search(arr, target_missing)  # ищем отсутствующее значение
print(f"Ищем {target_missing}: индекс =", idx2)  # результат «не найдено» (-1)
#Вывод: массив: [1, 3, 5, 7, 9, 11, 13, 15, 18, 23, 34, 42, 58, 73, 99, 127, 159, 356, 480, 567]
#Ищем 42: индекс = 11
#Ищем 100: индекс = -1


def ternary_search(arr, target):  # тернарный поиск в отсортированном списке
    left = 0  # левая граница диапазона (включительно)
    right = len(arr) - 1  # правая граница диапазона (включительно)
    while left <= right:  # продолжаем, пока диапазон не пуст
        third = (right - left) // 3  # размер трети диапазона
        mid1 = left + third  # первая середина
        mid2 = right - third  # вторая середина
        if arr[mid1] == target:  # если нашли в первой середине
            return mid1  # возвращаем индекс
        if arr[mid2] == target:  # если нашли во второй середине
            return mid2  # возвращаем индекс
        if target < arr[mid1]:  # цель левее первой середины
            right = mid1 - 1  # сузить поиск к левому сегменту
        elif target > arr[mid2]:  # цель правее второй середины
            left = mid2 + 1  # сузить поиск к правому сегменту
        else:  # иначе цель между mid1 и mid2
            left = mid1 + 1  # сузить к среднему сегменту
            right = mid2 - 1  # скорректировать правую границу
    return -1  # не найдено — вернуть -1

# Отсортированный тестовый массив
arr = [-10, -3, 0, 1, 3, 5, 7, 9, 11, 18, 23, 34, 42, 42, 58, 73, 99]  # демонстрационные данные

# Цели поиска
target_found = 42  # присутствует в массиве
target_missing = 100  # отсутствует

# Демонстрация работы
print("Массив:", arr)  # печать исходного массива
idx1 = ternary_search(arr, target_found)  # ищем существующее значение
print(f"Ищем {target_found}: индекс =", idx1)  # результат «найдено»
idx2 = ternary_search(arr, target_missing)  # ищем отсутствующее значение
print(f"Ищем {target_missing}: индекс =", idx2)  # результат «не найдено» (-1)
#Вывод: массив: [-10, -3, 0, 1, 3, 5, 7, 9, 11, 18, 23, 34, 42, 42, 58, 73, 99]
#Ищем 42: индекс = 13
#Ищем 100: индекс = -1