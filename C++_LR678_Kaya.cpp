// Сортировка выбором
#include <iostream> // Подключаем библиотеку ввода-вывода

// Функция для вывода содержимого массива
void printArray(int arr[], int size) {
    for (int i = 0; i < size; ++i) { // Проходим по каждому элементу массива
        std::cout << arr[i] << " ";   // Выводим значение элемента
    }
    std::cout << "\n";                // Переход на новую строку после печати всего массива
}

// Основная функция сортировки выбором
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) {           // Внешний цикл проходит по массиву до предпоследнего элемента
        int minIndex = i;                       // Предполагаемый индекс минимального элемента (начиная с текущего)
        
        // Внутренний цикл ищет минимальное значение справа от текущей позиции
        for (int j = i + 1; j < n; ++j) {       // Ищем минимальное значение среди всех последующих элементов
            if (arr[j] < arr[minIndex]) {       // Если нашли меньший элемент...
                minIndex = j;                   // Запоминаем новый индекс минимального значения
            }
        }
    
        // Меняем местами найденный минимум с элементом на текущей позиции
        if (minIndex != i) {                    // Проверка нужна лишь для оптимизации, чтобы избежать лишней операции swap
            std::swap(arr[i], arr[minIndex]);   // Используем стандартную функцию swap для перестановки значений
        }
    }
}

// Главная функция программы
int main() {
    int array[] = {64, 25, 12, 22, 11};      // Пример исходного несортированного массива
    int size = sizeof(array)/sizeof(array[0]); // Вычисляем размер массива автоматически
    
    std::cout << "Исходный массив:\n";
    printArray(array, size);                  // Печать исходного состояния массива
    
    selectionSort(array, size);               // Выполняем сортировку выбором
    
    std::cout << "Отсортированный массив:\n";
    printArray(array, size);                  // Печать результата
    
    return 0;                                 // Завершаем программу успешно
}

//Вывод: исходнаый массив: 64 25 12 22 11
//      отсортированный массив: 11 12 22 25 64



// Сортировка слиянием
#include <iostream>
#include <vector>
using namespace std;

// Слияние двух отсортированных подмассивов: arr[left..mid] и arr[mid+1..right]
void merge(vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    vector<int> L(n1), R(n2);
    for (int i = 0; i < n1; ++i) L[i] = arr[left + i];
    for (int j = 0; j < n2; ++j) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    // Стабильное слияние: равные элементы берём из левого подмассива первыми (<=)
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) arr[k++] = L[i++];
        else              arr[k++] = R[j++];
    }
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

// Рекурсивная сортировка слиянием для подмассива arr[left..right]
void mergeSort(vector<int>& arr, int left, int right) {
    if (left >= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

int main() {
    vector<int> arr = {38, 27, 43, 3, 9, 82, 10};
    mergeSort(arr, 0, static_cast<int>(arr.size()) - 1);

    for (size_t i = 0; i < arr.size(); ++i) {
        cout << arr[i] << (i + 1 == arr.size() ? '\n' : ' ');
    }
    return 0;
}

// вывод: 3 9 10 27 38 43 82


// Алгоритм пирамидальной сортировки
#include <iostream>  // ввод-вывод в консоль
#include <vector>    // контейнер std::vector для динамического массива
#include <algorithm> // std::swap для обмена элементов

using std::cout;  // импортируем cout для компактности
using std::endl;  // импортируем endl для переноса строки
using std::vector; // импортируем vector

void print_vec(const vector<int>& a) { // функция печати массива
    for (size_t i = 0; i < a.size(); ++i) { // проходим по всем элементам
        cout << a[i] << (i + 1 == a.size() ? '\n' : ' '); // печатаем значение и разделитель
    } // конец цикла печати
} // конец функции print_vec

void heapify(vector<int>& a, int n, int i) { // просеивание вниз: восстанавливает max-heap в поддереве i
    int largest = i;              // предполагаем текущий индекс корнем максимума
    int l = 2 * i + 1;            // левый ребёнок
    int r = 2 * i + 2;            // правый ребёнок
    if (l < n && a[l] > a[largest]) largest = l; // если левый больше текущего максимума — обновляем
    if (r < n && a[r] > a[largest]) largest = r; // если правый больше текущего максимума — обновляем
    if (largest != i) {           // если максимум не в корне поддерева
        std::swap(a[i], a[largest]); // меняем местами корень и большего ребёнка
        heapify(a, n, largest);      // рекурсивно восстанавливаем кучу в затронутом поддереве
    } // конец проверки перестановки
} // конец функции heapify

void build_max_heap(vector<int>& a) { // построение max-heap из произвольного массива
    int n = static_cast<int>(a.size()); // размер массива/кучи
    for (int i = n / 2 - 1; i >= 0; --i) { // спускаемся от последнего внутреннего узла к корню
        heapify(a, n, i); // восстанавливаем свойство кучи в поддереве i
    } // конец цикла построения
} // конец функции build_max_heap

void heap_sort(vector<int>& a) { // пирамидальная сортировка (in-place)
    int n = static_cast<int>(a.size()); // размер массива
    build_max_heap(a); // шаг 1: строим максимальную кучу
    for (int end = n - 1; end > 0; --end) { // шаг 2: многократно переносим максимум в хвост
        std::swap(a[0], a[end]); // кладём текущий максимум (корень) в конец неотсортированной части
        heapify(a, end, 0); // восстанавливаем кучу на уменьшенном префиксе [0, end)
    } // конец цикла извлечений
} // конец функции heap_sort

int main() { // точка входа
    vector<int> arr = {64, 34, 25, 12, 22, 11, 90, 88, 45, 50, 23, 36, 18, 77}; // тестовый массив
    cout << "Исходный: "; // префикс для исходного массива
    print_vec(arr); // печатаем исходный массив
    heap_sort(arr); // сортируем пирамидой
    cout << "Отсортированный: "; // префикс для результата
    print_vec(arr); // печатаем отсортированный массив
    return 0; // успешное завершение
} // конец main
// вывод: исходный: 64, 34, 25, 12, 22, 11, 90, 88, 45, 50, 23, 36, 18, 77
// отсортированный: 11, 12, 18, 22, 23, 25, 34, 36, 45, 50, 64, 77, 88, 90


// Интерполирующий поиск
#include <iostream>  // вывод в консоль
#include <vector>    // контейнер std::vector
#include <iomanip>   // для форматирования вывода (опционально)

using std::cout;   // упрощаем обращение к cout
using std::endl;   // упрощаем перенос строки
using std::vector; // упрощаем обращение к vector

int interpolation_search(const vector<int>& a, int target) { // функция интерполяционного поиска
    int low = 0;                          // левая граница диапазона (включительно)
    int high = static_cast<int>(a.size()) - 1; // правая граница диапазона (включительно)

    while (low <= high && target >= a[low] && target <= a[high]) { // продолжаем, пока цель в краях
        if (a[high] == a[low]) {        // защита от деления на ноль при равных значениях на краях
            return (a[low] == target) ? low : -1; // если совпадает — нашли, иначе нет
        }

        // формула интерполяции: оценка позиции pos
        // pos = low + (target - a[low]) * (high - low) / (a[high] - a[low])
        long long num = 1LL * (target - a[low]) * (high - low); // числитель (в 64-бит для безопасности)
        long long den = 1LL * (a[high] - a[low]);               // знаменатель (разброс значений)
        int pos = low + static_cast<int>(num / den);            // оценка индекса pos

        if (pos < low || pos > high) { // дополнительная защита от выхода за границы
            return -1;                 // если оценка вне диапазона — элемента нет
        }

        if (a[pos] == target) { // проверяем найден ли элемент по оценке
            return pos;         // возвращаем индекс найденного элемента
        } else if (a[pos] < target) { // если оценка меньше цели
            low = pos + 1;           // сдвигаем левую границу вправо
        } else {                     // иначе оценка больше цели
            high = pos - 1;          // сдвигаем правую границу влево
        }
    }
    return -1; // цель вне текущего диапазона или диапазон опустел — не найдено
}

void print_vec(const vector<int>& a) {            // вспомогательная функция печати массива
    for (size_t i = 0; i < a.size(); ++i) {       // проходим по всем элементам
        cout << a[i] << (i + 1 == a.size() ? '\n' : ' '); // печатаем элементы через пробел
    }
}

int main() { // точка входа
    vector<int> arr = {-10, -3, 0, 1, 3, 5, 7, 9, 11, 18, 23, 42, 42, 99}; // отсортированный массив
    cout << "Массив: ";                       // префикс строки
    print_vec(arr);                           // печатаем массив

    int target_found = 42;                    // значение, которое есть в массиве
    int target_missing = 100;                 // значение, которого нет в массиве

    int idx1 = interpolation_search(arr, target_found);   // поиск существующего значения
    int idx2 = interpolation_search(arr, target_missing); // поиск отсутствующего значения

    cout << "Ищем " << target_found << ": индекс = " << idx1 << endl; // печать результата 1
    cout << "Ищем " << target_missing << ": индекс = " << idx2 << endl; // печать результата 2

    return 0; // успешное завершение программы
}
// Вывод: Массив: -10 -3 0 1 3 5 7 9 11 18 23 42 42 99
// Ищем 42: индекс = 11
// Ищем 100: индекс = -1