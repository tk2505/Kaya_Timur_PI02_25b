Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.
Объяснение работы алгоритма:
1.	Определяется количество корзин (например, по диапазону значений элементов).
 mn = min(arr)  
mx = max(arr)
rng = mx - mn
2. Каждый элемент помещается в корзину согласно функции распределения.
idx = int((x - mn) / rng * (k - 1))
buckets[idx].append(x)
3.	Содержимое каждой корзины сортируется индивидуально.
for b in buckets:
insertion_sort(b)
4.	Корзины соединяются в порядке увеличения диапазона.
res = []
for b in buckets:
res.extend(b)
Временная сложность: O(n^2)
Объяснение: 2 вложенных цикла в алгоритме вставок если почти все элементы попадают в одну корзину.


Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.
Объяснение работы алгоритма:
1.	Найти максимальный элемент в неотсортированной части массива.
mi = max_index(a, size)
if a[i] > a[mx_i]:
mx_i = i
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот
элемент оказался первым.
if mi != 0:
flip(a, mi)
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
flip(a, size - 1)
4. Повторить процесс для оставшейся неотсортированной части массива.
while size > 1: (весь цикл заново)
size -= 1
Временная сложность: O(n^2)
Объяснение: на каждом из n шагов алгоритм тратит линейное время на поиск максимума и перевороты в префиксе длины m.


Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации.
Объяснение работы алгоритма:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин,
количество которых соответствует его значению.
grid = [[0] * m for _ in range(n)]
for i, val in enumerate(arr):
for j in range(val):
grid[i][j] = 1
2. Бусины располагаются на «стержнях» (как на абаке).
for i, val in enumerate(arr):
for j in range(val):
grid[i][j] = 1
3. Под действием «гравитации» бусины падают вниз.
for j in range(m):
 count = 0
 for i in range(n):
 count += grid[i][j]
 grid[i][j] = 0
 for i in range(n - 1, n - 1 - count, -1):
 grid[i][j] = 1
4. После оседания бусин строки считываются сверху вниз — получается
отсортированный массив.
res = [0] * n
for i in range(n):
s = 0
for j in range(m):
s += grid[i][j]
res[i] = s
 Временная сложность: O(n^2) 
Объяснение: максимальное количество вложенных циклов – 2, каждый выполняет свою работу до n раз.


Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.
Объяснение работы алгоритма:
1.	Делится массив на блоки длины m=n.
n = len(arr)
step = int(math.sqrt(n))
prev = 0
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный
искомому.
while prev < n and arr[min(prev + step, n) - 1] < target:
    prev += step
    if prev >= n:
        return -1
3. Если найденный элемент больше искомого, выполняется линейный поиск в
предыдущем блоке. 
end = min(prev + step, n)
i = prev
while i < end and arr[i] < target:
    i += 1
if i < end and i < n and arr[i] == target:
    return i
return -1
Временная сложность: O(n^0,5)
Объяснение: выполняется линейный поиск скачками корень из n


Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.
Объяснение работы алгоритма:
1. Проверяется первый элемент массива.
if n == 0: 
return -1
 if arr == target:
 return 0
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д.,
пока не будет найден элемент, больше или равный искомому.
i = 1
while i < n and arr[i] <= target:
 i = i * 2
3. На найденном диапазоне выполняется бинарный поиск.
left = i // 2
 right = min(i, n - 1)
return binary_search(arr, left, right, target
Временная сложность: O(log n) 
Объяснение: позиция искомого индекса увеличивается логарифмически


Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи).
Объяснение работы алгоритма:
1. Делится диапазон индексов на три части.
third = (right - left) // 3
 mid1 = left + third
  mid2 = right - third 
2. Сравнивается искомый элемент с элементами на двух разделительных границах.
if arr[mid1] == target: 
            return mid1  
        if arr[mid2] == target:  
            return mid2
3. Если совпадение не найдено, алгоритм повторяется рекурсивно в одной из трети
массива, где может находиться искомое значение.
if target < arr[mid1]:  
            right = mid1 - 1  
        elif target > arr[mid2]:  
            left = mid2 + 1  
        else:  
            left = mid1 + 1  
            right = mid2 – 1
Временная сложность: O(log3 n) 
Объяснение: диапазон уменьшается до одной трети на каждой итерации, а количество итераций равно log3 n  с константой из двух сравнений на шаг.
