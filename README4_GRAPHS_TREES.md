Дерево — иерархическая структура данных из узлов, где у каждого узла один родитель (кроме корня) и возможно несколько детей; корень не имеет родителя, листья не имеют детей, и такая модель используется, например, для файловых систем и оргструктур.

Граф — нелинейная структура из вершин и рёбер; формально граф задаётся как G=(U,E) где U — множество вершин, E — множество рёбер, причём ребро можно представить парой e=[x,y] графы бывают ориентированными/неориентированными и взвешенными/невзвешенными.

Для бинарных деревьев во всех трёх языках используется узел с ключом и ссылками на левого/правого потомков, а операции вставки, поиска и удаления приводятся как в рекурсивных, так и в итеративных вариантах.
Python: класс Node хранит key/left/right, отсутствующие поддеревья кодируются None; класс Tree держит root, а операции search/insert/delete реализуются рекурсивно и без рекурсии, включая вспомогательные функции вроде find_min для удаления.
Java: внутренний статический класс Node с полями key/left/right и класс Tree с полем root; insert реализован с рекурсивной doInsert и альтернативным итеративным спуском с учётом случаев пустого дерева и дубликатов.
C++: структура TNode с указателями Left/Right, рекомендуется инициализация через списки и использование nullptr; класс TTree снабжается деструктором для рекурсивного освобождения памяти, а нерекурсивная вставка элегантно решается через указатель на указатель (TNode**).

Формирование графов и поиск кратчайших путей реализуются через Дейкстру на трёх языках с разными представлениями: матрица смежности и список смежности с приоритетной очередью.
Python: граф — словарь словарей соседей и весов, для Дейкстры используется heapq как приоритетная очередь, расстояния инициализируются infinity, а улучшения релаксируются по мере извлечения минимальной вершины.
Java: два подхода — матрица смежности с массивами visited/distance и функцией выбора минимума, а также список смежности через ArrayList<Edge>[] с PriorityQueue<Pair> и накоплением веса до вершины (wsf).
C++: граф — vector<vector<Edge>> с полями destination/weight, применяется priority_queue с компаратором для минимального расстояния, массив distances и previous позволяют восстановить путь и вывести кратчайшую стоимость.

Реализация Алгоритма Дейкстры с помощью графов (Python):
1.	Импорт и инициализация
import heapq # Приоритетная очередь (мин-куча).
distances = {v: float('inf') for v in graph} # Все расстояния = ∞.
distances[start] = 0 # Источник = 0.
pq = [(0, start)] # Куча начинается с (0, источник).
2.	Основной цикл с извлечением минимума
dist, v = heapq.heappop(pq) # Берём вершину с наименьшей оценкой.
if dist > distances[v]: continue # Пропускаем устаревшую пару.
3.	Релаксация исходящих рёбер
for u, w in graph[v].items(): # Обходим соседей v.
nd = dist + w  # Кандидат на улучшение.
if nd < distances[u]:  # Условие релаксации.
distances[u] = nd  # Фиксируем лучший путь.
heapq.heappush(pq, (nd, u))  # Кладём обновлённую оценку.
Сложность: O(n log n) так как до V извлечений минимума и до E вставок, каждая за O(log V).

C++:
1.	Заголовки и модели данных
#include <vector> // Список смежности.
#include <queue> // priority_queue.
#include <limits> // numeric_limits для ∞.
struct Edge { int destination; int weight; }; // Рёбра.
2.	Инициализация
vector<int> dist(n, std::numeric_limits<int>::max()); // dist = ∞.
dist[s] = 0; // Источник.
priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq; // Мин-куча.
pq.push({0, s}); // Начальное состояние.
3.	Основной цикл и релаксации
while(!pq.empty()){ // Пока есть кандидаты.
auto cur = pq.top(); pq.pop(); int d = cur.first, v = cur.second; // Минимум.
if(d > dist[v]) continue; // Пропуск устаревшего.
for(const auto& e : g[v]){ // Соседи v.
int nd = d + e.weight; if(nd < dist[e.destination]){ dist[e.destination] = nd; pq.push({nd, e.destination}); }  // Релаксация и push.
Сложность: O(n log n) из-за логарифмических вставок/извлечений и суммарного числа операций, ограниченного V извлечениями и до E улучшениями.

Java:
Задействуются ArrayList<Edge>[] и PriorityQueue<Pair> с compareTo по весу “wsf”, а boolean[] visited фиксирует вершину при первом извлечении.
1.	Импорт и модели данных
import java.util.*; // Коллекции и PriorityQueue.
static class Edge { int nbr, weight; } // Ребро к соседу с весом.
static class Pair implements Comparable<Pair> { int v, wsf; public int compareTo(Pair o){ return this.wsf - o.wsf; } } // Мин-куча по wsf.
2.	Инициализация структур
int n = g.length; int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); // dist = ∞.
boolean[] vis = new boolean[n]; // Не зафиксированы.
ProrityQueue<Pair> pq = new PriorityQueue<>(); // Мин-куча.
dist[src] = 0; pq.add(new Pair(src, 0)); // Источник.
3.	Основной цикл Дейкстры
while(!pq.isEmpty()){ // Пока есть кандидаты.
Pair cur = pq.remove(); // Минимальный wsf.
if(vis[cur.v]) continue; // Пропуск устаревшего.
vis[cur.v] = true; // Фиксация кратчайшей дистанции.
for(Edge e: g[cur.v]){ // Релаксация рёбер.
int nd = cur.wsf + e.weight;  // Кандидат.
if(nd < dist[e.nbr]){ dist[e.nbr] = nd; pq.add(new Pair(e.nbr, nd)); }  // Обновление и push.
} }
Сложность: O(n log n) по тем же причинам, что и в Python (логарифмические операции кучи; до V извлечений и до E успешных релаксаций).

