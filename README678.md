Алгоритм сортировки выбором — это метод сортировки, при котором на каждом шаге определяется минимальный (или максимальный) элемент среди оставшихся элементов массива и ставится на соответствующую позицию в уже отсортированную часть массива. Процесс повторяется до полной сортировки массива.
Краткое описание работы кода:
Алгоритм последовательно выбирает минимальный элемент из неотсортированной части массива и помещает его в начало отсортированной части. Процесс продолжается до полного упорядочивания массива.
Во внешней петле выбирается позиция, куда будем ставить следующий минимальный элемент.
Во внутренней петле ищется минимальный элемент среди остальных элементов массива.
Найденный минимальный элемент меняется местами с первым элементом в текущей неотсортированной части.
Результат работы — отсортированный массив в порядке возрастания.
Время работы алгоритма оценивается как O(n^2)
Объяснение: так как два вложенных списка, каждый из которых в худшем случае зависит от n.


Алгоритм сортировки пузырьком - простой обменный алгоритм, который многократно проходит по массиву, попарно сравнивает соседние элементы и меняет их местами при нарушении порядка, из‑за чего большие значения «всплывают» к концу массива за один проход.
Краткое описание работы кода:
Внешний цикл организует последовательные проходы, а внутренний сравнивает пары только до границы n−1−i, поскольку «хвост» справа уже отсортирован после каждого прохода.
Обмен соседних элементов выполняется одной строкой через множественное присваивание arr[j], arr[j+1] = arr[j+1], arr[j] без временной переменной.
Флаг swapped отмечает, были ли обмены за проход. Если обменов не было, алгоритм немедленно завершает работу, так как массив уже отсортирован.
Временная сложность: O(n^2)
Объяснение: когда элементы изначально упорядочены в обратном порядке; выполняется порядка n(n-1)/2 сравнений и обменов. 


Сортировка вставками — это алгоритм, который проходит элементы последовательности слева направо, поддерживая слева отсортированную часть и на каждом шаге вставляя текущий элемент в корректную позицию среди уже отсортированных, сдвигая все большие элементы на одну позицию вправо.
Краткое описание работы кода:
Алгоритм последовательно проходит массив слева направо, поддерживая слева отсортированную часть и «вставляя» текущий элемент key в корректную позицию среди уже отсортированных элементов путём сдвига большего элемента вправо.
После i-й итерации первые i+1 элементов упорядочены, а вся сортировка выполняется на месте без вспомогательных массивов (in‑place).
Временная сложность: O(n^2)
Объяснение: из‑за квадратичного числа сравнений и сдвигов при произвольном или обратно упорядоченном входе.


Сортировка слиянием — это алгоритм «разделяй и властвуй», который рекурсивно разбивает массив на две части до единичных элементов, а затем сливает отсортированные половины в один массив, на каждом шаге выбирая меньший из текущих элементов двух подмассивов.
Краткое описание работы кода:
Деление: вычисляется mid и подмассивы [left..mid] и [mid+1..right] независимо сортируются тем же методом до базового случая длины 1, поскольку любой массив из одного элемента уже отсортирован.
Слияние: создаются временные буферы L и R, заводятся указатели i и j на начала буферов и k на позицию в исходном массиве, после чего в arr по очереди записывается меньший из L[i] и R[j] до исчерпания одного буфера.
Хвост: оставшиеся элементы непустого буфера целиком дописываются в arr, завершая формирование отсортированного отрезка.
Временная сложность: O(n log n)
Объяснение: так как глубина рекурсии равна log n, а на каждом уровне выполняется линейное слияние по всем элементам.


Сортировка Шелла — это обобщение сортировки вставками, где массив многократно упорядочивается по нескольким убывающим «разрывам» h, то есть элементы сравниваются и перемещаются через интервалы h, а завершается алгоритм проходом с h=1 (обычные вставки).
Краткое описание работы кода:
Функции: shell_sort выполняет собственно сортировку Шелла как серию gapped insertion sort для разрывов n//2,n//4,…,1n//2,n//4,…,1; parse_numbers разбирает входные данные в числа; main организует чтение из stdin, вызов сортировки и вывод результата.
Переменные: n — размер массива; gap — текущий разрыв; i — индекс текущего элемента подпоследовательности; j — индекс для сдвигов при вставке; temp — сохраняемый элемент для вставки; arr — сортируемый список.
Циклы: внешний while уменьшает gap до 1; for перебирает позиции в каждой h подпоследовательности; внутренний while выполняет «вставку» с шагом gap, сдвигая элементы вправо, пока слева через gap находится больший элемент.
Временная сложность: O(n^2)
Объяснение: поскольку финальный проход с h=1 эквивалентен сортировке вставками, которая в худшем случае требует порядка n^2 сравнений/перемещений, а предыдущие проходы при такой схеме не гарантируют снятие достаточного числа инверсий на специально выбранных входах.


Быстрая сортировка — алгоритм «разделяй и властвуй», в котором из подмассива выбирается опорный элемент, элементы переставляются так, чтобы слева оказались значения не больше опоры, а справа — строго больше, после чего рекурсивно сортируются обе части.
Краткое описание работы кода:
Функция quicksort: выполняет рекурсивную сортировку на месте
Функция partition: инкапсулирует разбиение Ломуто
Переменные left/right: задают границы текущего сегмента
Переменная pivot: опорный элемент (последний в сегменте)
Переменная i: граница секции элементов ≤ pivot
Переменная j: текущий индекс прохода
Переменная p: конечная позиция опоры после разбиения
Цикл for в partition: выполняет один линейный проход по сегменту для перестановок
Рекурсивные вызовы: сортируют левую и правую части до базового случая (сегмент размера 0 или 1)
Временная сложность: O(n^2)
Объяснение: когда опора постоянно выбирается крайне неудачно (например, первый/последний элемент в уже отсортированных данных), что приводит к глубине рекурсии O(n) и суммарно квадратичной работе.


Пирамидальная сортировка (heapsort) — сравнениями основанный алгоритм, который сначала преобразует массив в двоичную кучу (обычно max-heap), а затем многократно извлекает максимальный элемент, помещая его в конец массива, обеспечивая упорядочивание без дополнительной памяти.
Краткое описание работы кода:
Функции: heapify выполняет «просеивание вниз» для восстановления свойства max-heap в поддереве узла i, build_max_heap строит кучу за один проход снизу вверх, heap_sort объединяет эти шаги и делает многократные извлечения максимума, а print_vec выводит элементы массива.
Переменные: n хранит текущий размер кучи/массива, i — индекс узла при построении кучи, l и r — индексы левого и правого ребёнка, largest — индекс текущего максимума в тройке (узел и дети), end — граница неотсортированной части при фазе извлечения, arr — сортируемый вектор.
Циклы и рекурсия: цикл for в build_max_heap идёт от последнего внутреннего узла n/2−1n/2−1 к 0, вызывая heapify, а цикл for в heap_sort переносит максимум в конец и уменьшает кучу, тогда как рекурсивные вызовы heapify восстанавливают кучу логарифмической глубиной.
Временная сложность: O(n log n)
Объяснение: построение кучи за O(n) в подходе «снизу вверх» и n−1 извлечений максимума по O(log n) каждое, что суммарно даёт O(n)+O(n log n)= O(n log n)


  Линейный (последовательный) поиск — это простой алгоритм, который проверяет элементы последовательности один за другим до тех пор, пока не найдёт искомое значение или не закончится структура данных.
Краткое описание работы кода:
Функции: linear_search реализует собственно поиск и возвращает индекс первой найденной позиции либо −1; остальная часть скрипта задаёт тестовые данные и демонстрирует оба сценария — найдено/не найдено.
Переменные: arr — список, в котором ведётся поиск; target_found и target_missing — искомые значения для демонстрации; index и element — пара индекс/значение на каждой итерации; idx1 и idx2 — результаты поиска для соответствующих целей.
Циклы: основной цикл for с enumerate проходит по всем элементам слева направо и завершает работу досрочно при первом совпадении, что иллюстрирует поведение в лучшем случае.
Временная сложность: O(n)
Объяснение: в общем случае может потребоваться проверить все n элементов до обнаружения целевого значения или констатации его отсутствия.


Бинарный (двоичный) поиск — алгоритм для упорядоченных последовательностей, который на каждом шаге сравнивает искомое значение со средним элементом текущего диапазона и отбрасывает половину элементов, продолжая до успешного совпадения или опустошения диапазона.
Краткое описание работы кода:
Функция: binary_search возвращает индекс найденного элемента или −1, реализуя итеративный подход без срезов, что избегает лишних затрат и соответствует канонической форме алгоритма.
Переменные: left и right задают текущие границы поиска, mid — индекс середины диапазона, arr — отсортированный список, target — искомое значение, idx1/idx2 — результаты для сценариев «найдено» и «не найдено».
Цикл: while продолжает работу, пока диапазон не станет пустым, при каждом сравнении сужая область поиска вдвое за счёт корректного обновления границ left/right в зависимости от результата сравнения со средним элементом.
Временная сложность: O(log n)
Объяснение: после k итераций остаётся не более n/2^k элементов, и поиск останавливается при n/2^k≤1 то есть k≥⌈log2 n⌉


Интерполирующий поиск — алгоритм для упорядоченных массивов, который оценивает позицию искомого элемента с помощью линейной интерполяции по значениям на границах текущего диапазона, а затем сужает диапазон поиска на основании сравнения с элементом в вычисленной позиции.
Краткое описание работы кода:
Функции: interpolation_search выполняет итеративный поиск по формуле интерполяции и возвращает индекс найденного элемента или −1, print_vec выводит массив для демонстрации, а main подготавливает тестовые данные и печатает результаты двух запусков.
Переменные: low и high задают текущие границы поиска, pos — оценённый индекс по формуле, target — искомое значение, arr — отсортированный по возрастанию массив, idx1/idx2 — результаты поиска для «найдено/не найдено».
Цикл: while продолжается пока цель находится в диапазоне [a[low], a[high]] и сужает границы в зависимости от сравнения a[pos] с target, а проверка a[high] == a[low] предотвращает деление на ноль в вырожденном поддиапазоне.
Временная сложность: O(n)
Объяснение: распределение значений сильно неравномерно или оценки систематически «промахиваются», что приводит к последовательному исключению малых частей диапазона.


Поиск по Фибоначчи — алгоритм поиска в упорядоченном массиве, который выбирает позиции для сравнений, используя числа Фибоначчи вместо точной середины как в бинарном поиске.
Краткое описание работы кода:
Функции: fibonacci_search выполняет итеративный поиск и возвращает индекс найденного элемента или −1; остальной код задаёт тестовые данные и выводит результаты двух сценариев.
Переменные: n — размер массива; fib_mm2, fib_mm1, fib_m — тройка Fm−2,Fm−1,FmFm−2,Fm−1,Fm; offset — левая граница исключённого префикса; i — индекс текущей проверки; arr — отсортированный список; target — искомое значение; idx1/idx2 — результаты вызовов.
Цикл: первый while наращивает Fm до не меньшего n; основной while выбирает позицию i на основе Fm−2, сравнивает и соответственно сужает диапазон, обновляя тройку чисел Фибоначчи, пока не найден элемент или не исчезнет смысл продолжать.
Временная сложность: O(log n)
Объяснение: на каждом шаге объём рассматриваемого диапазона уменьшается по схеме, эквивалентной логарифмическому числу сравнений (с использованием близких к «золотому сечению» долей через числа Фибоначчи).


