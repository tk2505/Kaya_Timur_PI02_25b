1.	Вариант 5. Покрытие множеств с жадным алгоритмом Задача: реализовать жадный ln(n)-аппроксимационный алгоритм для задачи о покрытии множеств. Требования: - Входные данные: универсальное множество и семейство подмножеств - Выход: минимальное количество выбранных множеств - Вывести выбранные множества и общее количество элементов Входные данные: Универсум: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} Подмножества: S1={1,2,3}, S2={2,4,6}, S3={3,5,7}, S4={1,4,7,10}, S5={5,6,8,9}
2.	Алгоритм работы:
1) Прочитать универсум и m: используйте простой split по пробелам и целочисленное m, чтобы задать цикл чтения семейств.
universe = input().split(); m = int(input()).
2) Считать подмножества и фильтровать элементы по универсуму: разбейте строку по «:» при наличии имени, иначе автоимя S{i+1}, затем приведите к множеству и пересеките с universe для очистки.
line = input().strip(); name, rest = (line.split(':',1)+[line])[:2] if ':' in line else (f"S{i+1}", line); S[name.strip()] = set(rest.split()) & set(universe).
3) Инициализировать состояние: храните множество непокрытых элементов U, список выбранных имён C и копию исходных множеств для финального вывода.
U = set(universe); C = []; S_all = dict(S)
4) Жадный шаг выбора: пока есть непокрытые элементы, берите множество с максимальным «приростом» по числу новых покрытых элементов; при нулевом приросте завершайте как «нет покрытия».
while U: name, s = max(S.items(), key=lambda kv: len(kv[3] & U)); gain = len(s & U); затем if gain == 0: print("Невозможно покрыть..."); break.
5) Обновление после выбора: добавить имя в ответ, вычесть покрытые элементы из U, убрать множество из рассмотрения; это повторяется до полного покрытия.
C.append(name); U -= s; S.pop(name, None).
6) Вывод результата: порядок выбранных множеств, покрытое объединение и счётчики; объединение удобно взять из сохранённой копии S_all.
Пример: covered = set().union(*(S_all[n] for n in C)) if C else set(); print("Выбранные множества:", *C, sep="\n"); print("Покрытые элементы:", " ".join(sorted(covered))); print("Количество выбранных множеств:", len(C)); print("Суммарно покрыто элементов:", len(covered)).
3.	Временная сложность: O(n*m) где n – числов элементов универсума, m – число множеств
4.	Так как происходит не более n раундов, потому что каждый раунд покрывает хотя бы один ещё непокрытый элемент, и в каждом раунде он просматривает все m множеств, чтобы найти то, что даёт максимальный прирост
5.	Ответ на контрольный вопрос номер 5 “Почему жадный алгоритм для 0-1 рюкзака не гарантирует оптимальное решение? Приведите контрпример.”
Ответ: Жадный алгоритм по удельной ценности в 0–1 рюкзаке не видит выгодные комбинации предметов и может застрять в локальном максимуме, поэтому не гарантирует оптимум, в отличие от дробной версии, где он оптимален.
Контрпример:
Пусть вместимость рюкзака W, есть два предмета: w_1=1, v_1=2 и w_2=W, v_2=W. Жадный по удельной ценности выберет первый предмет (удельная ценность 2 против 1), получив суммарную ценность 2, тогда как оптимум - взять второй предмет с ценностью W (для W>2).

