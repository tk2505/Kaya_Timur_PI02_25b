#Сортировка пузырьком
def bubble_sort(arr): #Сортировка пузырьком
    n = len(arr)
    for i in range(n - 1):
        swapped = False
        for j in range(0, n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break
    return arr

# Пример использования:
data = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(data)) #вывод: [11, 12, 22, 25, 34, 64, 90]


#Сортировка вставками
def insertion_sort(arr): #Сортировка вставками
    # Проходим массив начиная со второго элемента
    for i in range(1, len(arr)):
        key = arr[i]      # текущий вставляемый элемент
        j = i - 1         # индекс для прохода по отсортированной части слева

        # Сдвигаем элементы, которые больше key, на одну позицию вправо
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1

        # Вставляем key в найденную позицию
        arr[j + 1] = key

    return arr

# Пример использования:
data = [12, 11, 13, 5, 6]
print(insertion_sort(data))  #Вывод: [5, 6, 11, 12, 13]


#Алгоритм сортировки Шелла
from typing import List, Union  # аннотации типов для читаемости

Number = Union[int, float]  # допустимые типы элементов (целые и вещественные)

def shell_sort(arr: List[Number]) -> List[Number]:  # основная функция сортировки Шелла
    # Реализация gapped insertion sort с разрывами n//2, n//4, ..., 1
    n = len(arr)  # длина массива
    gap = n // 2  # начальный разрыв по классической схеме Шелла
    while gap > 0:  # внешний цикл по убывающим разрывам
        for i in range(gap, n):  # перебор индексов в текущей h-подпоследовательности
            temp = arr[i]  # сохраняем текущий элемент для вставки в свою подпоследовательность
            j = i  # позиция для сдвигов на шаг gap
            while j >= gap and arr[j - gap] > temp:  # пока слева (через gap) элементы больше temp
                arr[j] = arr[j - gap]  # сдвигаем больший элемент вправо на gap
                j -= gap  # шагаем влево через gap для продолжения сравнения
            arr[j] = temp  # вставляем temp на найденное место
        gap //= 2  # уменьшаем разрыв вдвое для следующего прохода
    return arr  # возвращаем отсортированный список (сортировка выполняется на месте)

# Тестовый массив
test_array = [64, 34, 25, 12, 22, 11, 90, 88, 45, 50, 23, 36, 18, 77]  # неотсортированный массив для теста

print("Исходный массив:", test_array)  # выводим исходный массив
shell_sort(test_array)  # сортируем массив алгоритмом Шелла
print("Отсортированный массив:", test_array)  # выводим отсортированный результат
 
 #Вывод: Исходный массив: [64, 34, 25, 12, 22, 11, 90, 88, 45, 50, 23, 36, 18, 77]
#Отсортированный массив: [11, 12, 18, 22, 23, 25, 34, 36, 45, 50, 64, 77, 88, 90]


#Алгоритм быстрой сортировки
from typing import List, Union  # аннотации типов для читаемости

Number = Union[int, float]  # допускаем целые и вещественные числа

def quicksort(arr: List[Number], left: int = 0, right: int = None) -> List[Number]:  # быстрая сортировка (in-place)
    if right is None:  # если правая граница не задана
        right = len(arr) - 1  # сортируем до последнего индекса

    def partition(l: int, r: int) -> int:  # разбиение Ломуто: возвращает индекс опоры
        pivot = arr[r]  # выбираем опору как последний элемент сегмента
        i = l - 1  # i указывает на границу секции элементов ≤ pivot
        for j in range(l, r):  # однопроходный цикл по сегменту [l, r-1]
            if arr[j] <= pivot:  # если текущий элемент не больше опоры
                i += 1  # расширяем секцию ≤ pivot
                arr[i], arr[j] = arr[j], arr[i]  # ставим элемент в верную секцию свопом
        arr[i + 1], arr[r] = arr[r], arr[i + 1]  # помещаем опору на её окончательное место
        return i + 1  # возвращаем конечную позицию опоры

    if left < right:  # если в сегменте хотя бы два элемента
        p = partition(left, right)  # разбиваем сегмент и получаем индекс опоры
        quicksort(arr, left, p - 1)  # рекурсивно сортируем левый подмассив
        quicksort(arr, p + 1, right)  # рекурсивно сортируем правый подмассив
    return arr  # возвращаем ссылку на отсортированный список

# Тестовый массив
test_array = [64, 34, 25, 12, 22, 11, 90, 88, 45, 50, 23, 36, 18, 77]  # неотсортированный массив для теста

print("Исходный массив:", test_array)  # выводим исходный массив
quicksort(test_array)  # сортируем массив алгоритмом быстрой сортировки
print("Отсортированный массив:", test_array)  # выводим отсортированный результат
#Вывод: Исходный массив: [64, 34, 25, 12, 22, 11, 90, 88, 45, 50, 23, 36, 18, 77]
#Отсортированный массив: [11, 12, 18, 22, 23, 25, 34, 36, 45, 50, 64, 77, 88, 90]



#Последовательный (линейный) поиск
from typing import List, Union  # аннотации типов для читаемости

Number = Union[int, float, str]  # допустимые типы значений для поиска (числа и строки)

def linear_search(arr: List[Number], target: Number) -> int:  # линейный поиск: вернуть индекс или -1
    for index, element in enumerate(arr):  # перебираем массив по индексам и значениям
        if element == target:  # если текущий элемент равен искомому
            return index  # возвращаем индекс найденного элемента
    return -1  # если не найдено — вернуть -1

# Тестовый массив и цели поиска
arr = [23, 5, 7, 42, 5, 99, 0, -3, 42, 18]  # демонстрационный список для поиска
target_found = 42  # значение, которое гарантированно присутствует
target_missing = 100  # значение, которого нет в списке

# Поиск существующего значения
idx1 = linear_search(arr, target_found)  # выполняем линейный поиск для target_found
print("Массив:", arr)  # печатаем исходный массив
print(f"Ищем {target_found}: индекс =", idx1)  # печатаем найденный индекс (ожидается не -1)

# Поиск отсутствующего значения
idx2 = linear_search(arr, target_missing)  # выполняем линейный поиск для target_missing
print(f"Ищем {target_missing}: индекс =", idx2)  # печатаем -1, если элемент не найден
#Вывод: Массив: [23, 5, 7, 42, 5, 99, 0, -3, 42, 18]
#Ищем 42: индекс = 3
#Ищем 100: индекс = -1


#Бинарный поиск
from typing import List, Union  # аннотации типов для читаемости

Number = Union[int, float, str]  # допустимые типы значений для поиска (числа и строки)

def binary_search(arr: List[Number], target: Number) -> int:  # бинарный поиск: вернуть индекс или -1
    left = 0  # левая граница области поиска (включительно)
    right = len(arr) - 1  # правая граница области поиска (включительно)
    while left <= right:  # продолжаем, пока область поиска не пуста
        mid = (left + right) // 2  # индекс среднего элемента текущего диапазона
        if arr[mid] == target:  # если средний элемент равен искомому
            return mid  # возвращаем индекс найденного элемента
        elif arr[mid] < target:  # если средний элемент меньше искомого (массив отсортирован по возрастанию)
            left = mid + 1  # сдвигаем левую границу вправо, отбрасывая левую половину
        else:  # иначе средний элемент больше искомого
            right = mid - 1  # сдвигаем правую границу влево, отбрасывая правую половину
    return -1  # элемент не найден — возвращаем -1

# Отсортированный тестовый массив (по возрастанию)
arr = [-10, -3, 0, 1, 3, 5, 7, 9, 11, 18, 23, 42, 42, 99]  # демонстрационные данные

# Цели поиска
target_found = 42  # значение, которое присутствует в массиве
target_missing = 100  # значение, которого нет в массиве

# Демонстрация работы
print("Массив:", arr)  # печатаем исходный массив
idx1 = binary_search(arr, target_found)  # ищем существующее значение
print(f"Ищем {target_found}: индекс =", idx1)  # выводим индекс первого найденного вхождения 42
idx2 = binary_search(arr, target_missing)  # ищем отсутствующее значение
print(f"Ищем {target_missing}: индекс =", idx2)  # выводим -1 для отсутствующего элемента
#Вывод: Массив: [-10, -3, 0, 1, 3, 5, 7, 9, 11, 18, 23, 42, 42, 99]
#Ищем 42: индекс = 12
#Ищем 100: индекс = -1

#Поиск по Фибоначчи
def fibonacci_search(arr, target):  # объявляем функцию с параметрами arr (отсортированный список) и target (искомое значение)
    n = len(arr)  # сохраняем длину массива
    # Инициализируем три последовательных числа Фибоначчи: F(m-2), F(m-1), F(m)
    fib_mm2 = 0  # F(m-2) = 0 в начале
    fib_mm1 = 1  # F(m-1) = 1 в начале
    fib_m = fib_mm2 + fib_mm1  # F(m) = 1 на старте

    # Увеличиваем F(m) до первого числа Фибоначчи, не меньшего n
    while fib_m < n:  # пока текущее F(m) меньше размера массива
        fib_mm2, fib_mm1 = fib_mm1, fib_m  # сдвигаем пару (F(m-2), F(m-1)) вперёд
        fib_m = fib_mm2 + fib_mm1  # пересчитываем F(m) как сумму двух предыдущих

    offset = -1  # смещение «исключённой» слева части массива; изначально ничего не исключено

    # Основной цикл: продолжаем, пока есть элементы и target в пределах крайних значений
    while fib_m > 1 and offset < n - 1 and arr[0] <= target <= arr[-1]:  # условие наличия смысла поиска
        # Вычисляем индекс проверки i = min(offset + F(m-2), n-1)
        i = min(offset + fib_mm2, n - 1)  # выбираем позицию для сравнения на основе F(m-2)

        if arr[i] == target:  # если элемент найден в позиции i
            return i  # возвращаем индекс i
        elif arr[i] < target:  # если значение в i меньше цели, отбрасываем левую часть [offset..i]
            fib_m = fib_mm1  # сдвигаем «окно» вправо: новый F(m) = предыдущий F(m-1)
            fib_mm1 = fib_mm2  # новый F(m-1) = предыдущий F(m-2)
            fib_mm2 = fib_m - fib_mm1  # новый F(m-2) восстанавливаем как разность
            offset = i  # увеличиваем смещение до i
        else:  # иначе arr[i] > target — отбрасываем правую часть за i
            fib_m = fib_mm2  # новый F(m) = предыдущий F(m-2)
            fib_mm1 = fib_mm1 - fib_mm2  # новый F(m-1) = прежний F(m-1) - прежний F(m-2)
            fib_mm2 = fib_m - fib_mm1  # новый F(m-2) = новый F(m) - новый F(m-1)

    # Дополнительная проверка последнего возможного элемента
    if fib_mm1 and offset + 1 < n and arr[offset + 1] == target:  # если F(m-1) == 1 и кандидат в пределах
        return offset + 1  # возвращаем индекс offset+1

    return -1  # элемент не найден — возвращаем -1

# Отсортированный тестовый массив (по возрастанию)
arr = [-10, -3, 0, 1, 3, 5, 7, 9, 11, 18, 23, 34, 42, 42, 58, 73, 99]  # демонстрационные данные

# Цели поиска
target_found = 42  # значение, которое присутствует в массиве (есть два вхождения)
target_missing = 100  # значение, которого нет в массиве

# Демонстрация работы
print("Массив:", arr)  # печатаем исходный массив
idx1 = fibonacci_search(arr, target_found)  # ищем существующее значение
print(f"Ищем {target_found}: индекс =", idx1)  # выводим индекс одного из вхождений 42
idx2 = fibonacci_search(arr, target_missing)  # ищем отсутствующее значение
print(f"Ищем {target_missing}: индекс =", idx2)  # ожидается -1
#Вывод: Массив: [-10, -3, 0, 1, 3, 5, 7, 9, 11, 18, 23, 34, 42, 42, 58, 73, 99]
#Ищем 42: индекс = 12
#Ищем 100: индекс = -1

