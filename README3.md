Бинарная куча — полное бинарное дерево для приоритетной очереди: уровни заполнены слева направо, поддерживаются min-/max варианты, часто реализуется неявно в массиве с вычислением индексов родителя/детей.
Биномиальная куча — набор биномиальных деревьев попарно разных размеров с корнями минимумами; поддерживает эффективное слияние куч и строго определена: дерево порядка n содержит 2n узлов.
Куча Фибоначчи — структура приоритетной очереди с операциями insert, unite/merge, getMin, extractMin, decreaseKey и deleteElement; в файле приведена полноценная шаблонная реализация на C++ и отмечено отсутствие готовых структур в Python/Java разделах (там показаны примеры по ряду Фибоначчи).
Хеш таблица — отображение ключ→значение с обработкой коллизий методами цепочек или адресации; в файле показаны как стандартные контейнеры языков (dict, HashMap/Hashtable, unordered_map), так и учебные реализации с собственной хеш функцией и бакетами.
Python
Для бинарной/биномиальной кучи предлагается модуль heapq (min heap): heapify для превращения списка в кучу, heappush для вставки и heappop для извлечения минимума; для max heap предлагается инверсия знака ключей и возможность реализации собственного класса.
Отмечено, что структуры «куча Фибоначчи» в стандартной библиотеке Python нет; приведены учебные примеры вычисления ряда Фибоначчи циклом и рекурсией с базовыми случаями n∈{0,1}
Хеш таблица реализуется через встроенный dict (требуются хешируемые ключи) или учебный класс HashTable со своей _hash, методами set/get/remove и вариантом расширения до обработки коллизий и рехеширования.
Ключевые конструкции: модуль heapq и его функции heapify/heappush/heappop; тип dict как готовая хеш таблица; методы класса и простые хеш функции на основе ord/остатка по модулю.
C++
Бинарная куча оформлена как шаблонный класс MinHeap на std::vector с heapifyUp/heapifyDown, insert, extractMin, decreaseKey, deleteNode и проверками ошибок через исключения.
Биномиальная куча реализуется через узлы с полями parent/child/sibling и операциями Insert, Union, Merge, Extract_Min, Decrease_key и Delete, где связывание деревьев определяется по степеням (degree).
Куча Фибоначчи представлена шаблонным классом FibonacciHeap с узлами Element, поддержкой unite консолидирующих списков корней, link/cut/cascadingCut и полным набором операций приоритетной очереди.
Хеш таблицы показываются в двух вариантах: std::unordered_map как стандартная хеш карта и учебный HashTable на массиве списков (std::list) со std::hash и разрешением коллизий методами цепочек.
Ключевые конструкции: шаблоны классов, std::vector/std::list, std::unordered_map, std::hash, обработка исключений, а также собственные структуры узлов и вспомогательные функции link/merge/consolidate.
Java
Двоичная куча реализована как обобщённый BinaryHeap<T extends Comparable<T)> на массиве с операциями add (просеивание вверх), pop (просеивание вниз), динамическим расширением массива и доступом к вершине.
Биномиальная куча строится на классах HeapNode/HeapItem с поддержкой insert, deleteMin, decreaseKey, delete и meld; слияние и связывание деревьев выполняются по рангу с переустановкой ссылок и пересчётом минимума.
В разделе «куча Фибоначчи» показан именно рекурсивный расчёт ряда Фибоначчи с формулой F(n)=F(n−1)+F(n−2)), а для хеш таблиц приведены стандартные Hashtable и HashMap с примерами put/get/remove/containsKey/size.
Ключевые конструкции: дженерики и сравнение через Comparable, массивы как базовое хранилище, стандартные коллекции и интерфейс Map для HashMap/Hashtable.
