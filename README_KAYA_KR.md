1. Задание?13. Генетический алгоритм: задача коммивояжёра
Условие. Найти приближённое решение TSP с помощью генетического алгоритма.
Алгоритм: ГА с упорядоченным кроссовером (OX) и мутацией перестановки.
Язык примера: C++
vector<int> gaTsp(const vector<vector<int>>& dist, int popSize, int generations) {
 vector<vector<int>> population = initPopulation(popSize, dist.size());
 for (int gen = 0; gen < generations; gen++) {
 vector<double> fitness = calcFitness(population, dist);
 // ДОПИСАТЬ: отбор родителей, кроссовер, мутация
 // обновить population
 // Вернуть лучший маршрут
}
Что дописать: функции отбора (например, турнирным методом), OX?кроссовера и
мутации перестановки.
2. Алгоритм:
1) Формализация  
Задать количество городов и матрицу расстояний между ними. 
vector<vector<int>> dist(n, vector<int>(n));
// cin >> dist[i][j];
2) Создание начальной популяции  
Сгенерировать множество случайных маршрутов (каждый – допустимая перестановка городов).
vector<vector<int>> population = initPopulation(popSize, n);
3) Оценка приспособленности  
Для каждого маршрута вычислить его “приспособленность” – обычно это обратная величина длины маршрута: чем короче маршрут, тем выше приспособленность.
vector<double> fitness = calcFitness(population, dist);
4) Отбор родителей  
В каждой итерации (поколении) выбрать пары маршрутов-родителей для скрещивания. Чаще всего используют турнирный или рулеточный метод. Отбираются маршруты с высокой приспособленностью.
int p1 = tournamentSelect(fitness, tournamentSize, rng);
int p2 = tournamentSelect(fitness, tournamentSize, rng);
5) Кроссовер (скрещивание)  
С помощью оператора кроссовера (например, упорядоченного OX-кроссовера) из пары родителей формируются новые маршруты (дети), наследуя порядок посещения городов от обоих родителей.
vector<int> child = orderedCrossover(population[p1], population[p2], rng);
6) Мутация  
С вероятностью, обычно небольшой (например, 0.1–0.2), выполняется мутация над каждым новым маршрутом (например, обмен двух случайных городов в маршруте).
if (mprob(rng) < mutationRate)
    mutate(child, rng);
7) Формирование нового поколения  
Новая популяция составляется из полученных потомков, и (иногда) части лучших представителей предыдущего поколения (элитизм).
newPopulation.push_back(child);
8) Проверка условия завершения  
Если достигнуто заданное число поколений или другая остановка (например, решение не улучшается), алгоритм завершается.
for (int gen = 0; gen < generations; ++gen) { ... }
9) Выбор лучшего решения  
В качестве ответа выбирается маршрут с минимальной длиной среди всех, которые были рассмотрены в процессе работы.
return population[bestInd];
3. Временная сложность: O(n^2)
4. Объяснение: квадратичность обусловлена тем, что для выполнения кроссовера и проверки маршрута приходится перебирать все элементы перестановки (n), а внутри для каждого элемента делать действия, которые могут вновь проходить по маршруту (n), то есть n^2
5. Вопрос: 13. Табу-поиск
Объясните концепцию табу-листа в алгоритме табу-поиска. Какую роль он играет?
Ответ:Табу-лист в алгоритме табу-поиска?—?это специальная память (список), в которую заносятся недавно посещённые решения или сделанные ходы, чтобы временно запретить возвращение к ним.  
Он играет ключевую роль: помогает избежать зацикливания и выхода из локального оптимума, не позволяя алгоритму возвращаться к уже рассмотренным неудачным состояниям.